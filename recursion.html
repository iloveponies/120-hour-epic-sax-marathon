<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Recursion</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <script src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span12"><div class="top-nav"><a href="index.html">← index</a></div>
<header>
<h1 class="title">Recursion</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<section class="level2" id="synopsis">
<h2>Synopsis</h2>
<p>Recursion is a large topic. This chapter covers the following:</p>
<ul>
<li>Linear recursion,</li>
<li>Recursion over numbers,</li>
<li>Tree recursion,</li>
<li>Nonlinear recursion,</li>
<li>Passing state, and</li>
<li>An application: merge sort.</li>
</ul>
</section>
<section class="level2" id="fork-this">
<h2>Fork this</h2>
<p><a href="https://github.com/iloveponies/recursion">https://github.com/iloveponies/recursion</a></p>
<p><a href="basic-tools.html#how-to-submit-answers-to-exercises">Here</a> are the instructions if you need them. Be sure to fork the repository behind the link above.</p>
</section>
<section class="level2" id="recap">
<h2>Recap</h2>
<p>This chapter talks a lot about collections and we’ll need the functions <code>first</code> and <code>rest</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">doc</span> <span class="kw">first</span>)
(<span class="kw">doc</span> <span class="kw">rest</span>)
(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])  <span class="co">;=&gt; 1</span>
(<span class="kw">first</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)) <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; (2 3 4)</span>
(<span class="kw">rest</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))  <span class="co">;=&gt; (2 3 4)</span>
(<span class="kw">rest</span> [<span class="dv">1</span>])         <span class="co">;=&gt; ()</span>
(<span class="kw">rest</span> [])          <span class="co">;=&gt; ()</span></code></pre>
<p><code>first</code> gives the first element of a sequence, and <code>rest</code> gives all but the first element.</p>
</section>
<section class="level2" id="recursion">
<h2>Recursion</h2>
<p>So far we’ve manipulated collections with functions like <code>map</code> and <code>filter</code>. How do they work? They are all based on <em>recursion</em>. Recursion is the low-level method of iteration found in functional languages. While the higher-level functions like <code>map</code> are usually nicer to use than implementing the equivalent algorithm with recursion ourselves, there are often situations when the structure of the algorithm or the data it operates on is such that the existing higher-level functions do not quite work on it.</p>
<section class="level3" id="lists-are-recursive-structures">
<h3>Lists are recursive structures</h3>
<p>Let’s look at the function <code>cons</code>. It takes two parameters, a value and a sequence, and returns a new sequence with the value added to the front of the original sequence. For an example, to construct the sequence <code>(1 2 3 4)</code>, we could write:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">cons</span> <span class="dv">1</span>
      (<span class="kw">cons</span> <span class="dv">2</span>
            (<span class="kw">cons</span> <span class="dv">3</span>
                  (<span class="kw">cons</span> <span class="dv">4</span> &#39;()))))
<span class="co">;=&gt; (1 2 3 4)</span></code></pre>
<p><code>'()</code> is the empty sequence.</p>
<p>To process this nested structure suggests that we should first process the first element of the sequence, and then do the operation again on the rest of the sequence. This is actually the general structure of <em>linear recursion</em>. As a concrete example, let’s look at how to implement <code>sum</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum </span>[coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    <span class="dv">0</span>
    (<span class="kw">+</span> (<span class="kw">first</span> coll)
       (sum (<span class="kw">rest</span> coll)))))

(sum [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 10</span></code></pre>
<p>The <em>sum</em> of a sequence is:</p>
<ul>
<li>0, if the sequence is empty, or</li>
<li>the <em>first</em> element of the sequence <em>added</em> to the <em>sum</em> of the <em>rest</em> of the sequence.</li>
</ul>
<p>Imagine an arrow drawn from the second <em>sum</em> to the first <em>sum</em>. This is the recursive nature of the algorithm.</p>
<p>The call to <code>sum</code> begins by inspecting <code>coll</code>. If <code>coll</code> is empty, <code>sum</code> immediately returns 0. If <code>coll</code> is not empty, <code>sum</code> takes its first element and adds it to the sum of the rest of the elements of <code>coll</code>. The value 0 is the base case of the algorithm, which determines when the calculation stops. If we did not have a base case, the calculation would continue infinitely.</p>
<section class="alert alert-success">
<h3>
Exercise 1
</h3>
<p>Write the function <code>(product coll)</code> that computes the product of a collection of values. The product of \(a\), \(b\) and \(c\) is \(a * b * c\).</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(product [])        <span class="co">;=&gt; 1  ; special case</span>
(product [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; 6</span>
(product [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 24</span>
(product [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>])   <span class="co">;=&gt; 0</span>
(product #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>})  <span class="co">;=&gt; 24 ; works for sets too!</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 2
</h3>
<p>Write down the evaluation of <code>(product [1 2 4])</code> like we did for <code>sum</code> above.</p>
</section>
<p>To get a better grasp on what <code>sum</code> does, let’s see how it’s evaluated.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (sum &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))
<span class="kw">=</span>   (sum (<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> (<span class="kw">cons</span> <span class="dv">4</span> &#39;())))))
<span class="co">;=&gt; (+ 1 (sum (cons 2 (cons 3 (cons 4 &#39;())))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (sum (cons 3 (cons 4 &#39;())))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (sum (cons 4 &#39;())))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (+ 4 (sum &#39;())))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (+ 4 0))))        ; (empty? &#39;()) is true, so (sum &#39;()) ;=&gt; 0</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 4)))</span>
<span class="co">;=&gt; (+ 1 (+ 2 7))</span>
<span class="co">;=&gt; (+ 1 9)</span>
<span class="co">;=&gt; 10</span></code></pre>
<p>Note that we expanded the list <code>'(1 2 3 4)</code> to its <code>cons</code> form. If we take a closer look at that form and the line with comment above, we’ll see why:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">   (<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> (<span class="kw">cons</span> <span class="dv">4</span> &#39;()))))
...
<span class="co">;=&gt; (+    1 (+    2 (+    3 (+    4   0))))</span></code></pre>
<p>We replaced the <code>cons</code> operation in the recursive structure with <code>+</code> and <code>'()</code> with <code>0</code>. That is, we transformed the data structure into a calculation with the same form but different result.</p>
<p>From this we get the general template for linear recursion over collections:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> eats-coll </span>[coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    ...
    (... (<span class="kw">first</span> coll) ... (eats-coll (<span class="kw">rest</span> coll)))))</code></pre>
<p>The first branch of the <code>if</code> is the base case and determines the value of <code>eats-coll</code> when given an empty collection. The second branch determines what operation to apply on the elements of the collection.</p>
<p>We call this kind of computation <em>linear</em> because the expression it constructs grows linearly with the size of input.</p>
<section class="alert alert-success">
<h3>
Exercise 3
</h3>
<p>Write the function <code>(singleton? coll)</code> which returns <code>true</code> if the collection has only a one element in it and <code>false</code> otherwise.</p>
<p>Do not use <code>count</code> as it can be expensive on long sequences.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(singleton? [<span class="dv">1</span>])     <span class="co">;=&gt; true</span>
(singleton? #{<span class="dv">2</span>})    <span class="co">;=&gt; true</span>
(singleton? [])      <span class="co">;=&gt; false</span>
(singleton? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; false</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 4
</h3>

<p>Write <code>(my-last a-seq)</code> that computes the last element of a sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-last [])      <span class="co">;=&gt; nil</span>
(my-last [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; 3</span>
(my-last [<span class="dv">2</span> <span class="dv">5</span>])   <span class="co">;=&gt; 5</span></code></pre>
<p>Hint: what is the base case here? How can you check if we’re there?</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 5
</h3>

<p>Write the function <code>(max-element a-seq)</code> that computes returns the maximum element in <code>a-seq</code> or <code>nil</code> if <code>a-seq</code> is empty?</p>
<p>You can use the function <code>(max a b)</code> that returns the greater of <code>a</code> and <code>b</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(max-element [<span class="dv">2</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">4</span>]) <span class="co">;=&gt; 4</span>
(max-element [<span class="dv">2</span>])       <span class="co">;=&gt; 2</span>
(max-element [])        <span class="co">;=&gt; nil</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 6
</h3>

<p>Write the function <code>(seq-max seq-1 seq-2)</code> that returns the longer one of <code>seq-1</code> and <code>seq-2</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(seq-max [<span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">2</span>])   <span class="co">;=&gt; [1 2]</span>
(seq-max [<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; [3 4]</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 7
</h3>

<p>Write the function <code>(longest-sequence a-seq)</code> that takes a sequence of sequences as a parameter and returns the longest one.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(longest-sequence [[<span class="dv">1</span> <span class="dv">2</span>] [] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]]) <span class="co">;=&gt; [1 2 3]</span>
(longest-sequence [[<span class="dv">1</span> <span class="dv">2</span>]])            <span class="co">;=&gt; [1 2]</span>
(longest-sequence [])                 <span class="co">;=&gt; nil</span></code></pre>
</section>
</section>
<section class="level3" id="saving-the-list">
<h3>Saving the list</h3>
<p>All the functions so far, <code>sum</code>, <code>product</code> and <code>last-element</code>, transformed the list into a single value. This it not always the case with linear recursion. Our old friend <code>(map f a-seq)</code> is an good example of this. Here is a definition for it:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> my-map </span>[f a-seq]
  (<span class="kw">if</span> (<span class="kw">empty?</span> a-seq)
    a-seq
    (<span class="kw">cons</span> (f (<span class="kw">first</span> a-seq))
          (my-map (<span class="kw">rest</span> a-seq)))))</code></pre>
<p>See how nicely it fits in the general template for linear recursion? Only deviation from it is the extra parameter <code>f</code>. It is function, that will become part of the operation that the recursion applies to the elements of the sequence. Here’s the evaluation:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">map</span> <span class="kw">inc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])
<span class="co">;=&gt; (cons (inc 1)</span>
<span class="co">;         (cons (inc 2)</span>
<span class="co">;               (cons (inc 3) &#39;())))</span>
<span class="co">;=&gt; &#39;(2 3 4)</span></code></pre>
<p>So <code>map</code> calls the function <code>f</code> for every element of <code>a-seq</code> and then re-constructs the sequence with <code>cons</code>.</p>
<section class="alert alert-success">
<h3>
Exercise 8
</h3>

<p>Implement the function <code>(my-filter pred? a-seq)</code> that works just like the standard <code>filter</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-filter <span class="kw">odd?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (1 3)</span>
(my-filter (<span class="kw">fn</span> [x] (<span class="kw">&gt;</span> x <span class="dv">9000</span>)) [<span class="dv">12</span> <span class="dv">49</span> <span class="dv">90</span> <span class="dv">9001</span>]) <span class="co">;=&gt; (9001)</span>
(my-filter <span class="kw">even?</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">7</span>]) <span class="co">;=&gt; ()</span></code></pre>
</section>
</section>
<section class="level3" id="stopping-before-the-end">
<h3>Stopping before the end</h3>
<p>Sometimes you can find the answer before hitting the base case. For example, the following function checks if a sequence contains only numbers. If we find something that isn’t a number on the way through, we can immediately stop and return <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> only-numbers</span>? [coll]
  (<span class="kw">cond</span>
   (<span class="kw">empty?</span> coll)
     true                        <span class="co">; the empty sequence contains only numbers</span>
   (<span class="kw">number?</span> (<span class="kw">first</span> coll))
     (only-numbers? (<span class="kw">rest</span> coll)) <span class="co">; we got a number, let&#39;s check the rest</span>
   <span class="kw">:else</span>
     false))                     <span class="co">; it wasn&#39;t a number so we have our answer</span></code></pre>
<p>Here the recursion stops if we hit the base case (empty collection) or if we find a non-number.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])    <span class="co">;=&gt; true</span>
(only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="kw">:D</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; false</span></code></pre>
<p>Let’s have a closer look at the evaluation of the second line:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">   (only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="kw">:D</span> <span class="dv">3</span> <span class="dv">4</span>])
<span class="co">;=&gt; (only-numbers? [2 :D 3 4]) ; (number? 1) =&gt; true, so we now need to check</span>
                               <span class="co">; if all the rest are numbers.</span>
<span class="co">;=&gt; (only-numbers? [:D 3 4])   ; because (number? 2) ;=&gt; true</span>
<span class="co">;=&gt; false                      ; because (number? :D) ;=&gt; false</span></code></pre>
<section class="alert alert-success">
<h3>
Exercise 9
</h3>

<p>Write the function <code>(sequence-contains? elem a-seq)</code> that returns <code>true</code> if the given sequence contains the given value, otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(sequence-contains? <span class="dv">3</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; true</span>
(sequence-contains? <span class="dv">3</span> [<span class="dv">4</span> <span class="dv">7</span> <span class="dv">9</span>]) <span class="co">;=&gt; false</span>
(sequence-contains? <span class="kw">:pony</span> [])  <span class="co">;=&gt; false</span></code></pre>
<p>Hint: remember to stop searching when you find it.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 10
</h3>
<p>Write the function <code>(my-take-while pred? a-seq)</code> that returns the longest prefix of <code>a-seq</code> where <code>pred?</code> returns <code>true</code> for every element.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-take-while <span class="kw">odd?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])  <span class="co">;=&gt; (1)</span>
(my-take-while <span class="kw">odd?</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>])  <span class="co">;=&gt; (1 3)</span>
(my-take-while <span class="kw">even?</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>]) <span class="co">;=&gt; ()</span>
(my-take-while <span class="kw">odd?</span> [])         <span class="co">;=&gt; ()</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 11
</h3>
<p>Write the function <code>(my-drop-while pred? a-seq)</code> that drops elements from <code>a-seq</code> until <code>pred?</code> returns <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-drop-while <span class="kw">odd?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])  <span class="co">;=&gt; (2 3 4)</span>
(my-drop-while <span class="kw">odd?</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>])  <span class="co">;=&gt; (4 5)</span>
(my-drop-while <span class="kw">even?</span> [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>]) <span class="co">;=&gt; (1 3 4 5)</span>
(my-drop-while <span class="kw">odd?</span> [])         <span class="co">;=&gt; ()</span></code></pre>
</section>
</section>
<section class="level3" id="recursing-over-many-sequences">
<h3>Recursing over many sequences</h3>
<p>The template for linear recursion is very simple and is often <em>too</em> simple. For an example, consider the function <code>(first-in val seq-1 seq-2)</code>, which returns <code>1</code> if the value <code>val</code> is found first in <code>seq-1</code> and <code>2</code> if in <code>seq-2</code>. If <code>val</code> is not found in either sequence, <code>first-in</code> returns <code>0</code>. <code>val</code> must not be <code>nil</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> first-in </span>[<span class="kw">val</span> seq<span class="dv">-1</span> seq<span class="dv">-2</span>]
  (<span class="kw">cond</span>
    (<span class="kw">and</span> (<span class="kw">empty?</span> seq<span class="dv">-1</span>) (<span class="kw">empty?</span> seq<span class="dv">-2</span>)) <span class="dv">0</span>
    (<span class="kw">=</span> (<span class="kw">first</span> seq<span class="dv">-1</span>) <span class="kw">val</span>) <span class="dv">1</span>
    (<span class="kw">=</span> (<span class="kw">first</span> seq<span class="dv">-2</span>) <span class="kw">val</span>) <span class="dv">2</span>
    <span class="kw">:else</span> (first-in <span class="kw">val</span> (<span class="kw">rest</span> seq<span class="dv">-1</span>) (<span class="kw">rest</span> seq<span class="dv">-2</span>))))</code></pre>
<p>There’s an obvious reason why <code>first-in</code> doesn’t fit our template for linear recursion: it has three parameters, whereas the template only takes one. We can ignore the first parameter for our purposes, since it does not have bearing on the recursive structure of the computation. <code>first-in</code> is linearly recursive on both its sequence parameters, though.</p>
<section class="alert alert-success">
<h3>
Exercise 12
</h3>
<p>Write the function <code>(seq= seq-1 seq-2)</code> that compares two sequences for equality.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(seq= [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>] &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>))  <span class="co">;=&gt; true</span>
(seq= [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; false</span>
(seq= [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>] [])        <span class="co">;=&gt; false</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 13
</h3>

<p>Write the function <code>(my-map f seq-1 seq-2)</code> that returns a sequence of the following kind . The first item is the return value of <code>f</code> called with the first values of <code>seq-1</code> and <code>seq-2</code>. The second item is the return value of <code>f</code> called with the second values of <code>seq-1</code> and <code>seq-2</code> and so forth until <code>seq-1</code> or <code>seq-2</code> ends.</p>
<p>This is actually exactly how <code>map</code> works when given two sequences, but for the sake of practice don’t use <code>map</code> when defining <code>my-map</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-map <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">4</span> <span class="dv">4</span> <span class="dv">4</span>]) <span class="co">;=&gt; (5 6 7)</span>
(my-map <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] [<span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>]) <span class="co">;=&gt; (1 2 3)</span>
(my-map <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] []) <span class="co">;=&gt; ()</span></code></pre>
</section>
<p>With the help of <code>my-map</code> (or <code>map</code>) and <code>vector</code> we can actually use our one-parameter template of linear recursion when we need to recurse over two sequences. We just zip together the two sequences and recurse over the resulting sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">vector</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;=&gt; [1 2]</span>
(<span class="kw">vector</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;=&gt; [1 2 3 4]</span>
(my-map <span class="kw">vector</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>]) <span class="co">;=&gt; ([1 :a] [2 :b] [3 :c])</span>
(<span class="kw">map</span> <span class="kw">vector</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>]) <span class="co">;=&gt; ([1 :a] [2 :b] [3 :c])</span></code></pre>
</section>
<section class="level3" id="recursion-on-numbers">
<h3>Recursion on numbers</h3>
<p>Another common data structure to recurse over are numbers. (Even though you might not think of numbers as data structures!) Recursing over numbers is very similar to recursing over sequences. As an example, let’s define a function to calculate the factorial of a number. (Factorial of n is 1 * 2 * … * (n-1) * n.)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> factorial </span>[n]
  (<span class="kw">if</span> (<span class="kw">zero?</span> n)
    <span class="dv">1</span>
    (<span class="kw">*</span> n (factorial (<span class="kw">dec</span> n)))))</code></pre>
<p>The <code>factorial</code> function looks a lot like <code>sum</code>. Given the number <code>n</code>, We have the base case (return 1 if <code>n</code> is zero) and the recursive branch, which multiplies <code>n</code> with the factorial of <code>(dec n)</code>, that is, <code>(- n 1)</code>. To verify that this function really does implement the definition of factorial properly, we can look at how it is evaluated:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (factorial <span class="dv">4</span>)
<span class="co">;=&gt; (* 4 (factorial 3))</span>
<span class="co">;=&gt; (* 4 (* 3 (factorial 2)))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (factorial 1))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 (factorial 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 1)))) ; Base case reached</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 1)))</span>
<span class="co">;=&gt; (* 4 (* 3 2))</span>
<span class="co">;=&gt; (* 4 6)</span>
<span class="co">;=&gt; 24</span></code></pre>
<p>The line where the base case is reached shows that the function does evaluate to the mathematical expression we wanted.</p>
<p>Let’s look a bit closer at how sequences and numbers are related. Where a sequence is <em>cons</em>tructed, numbers are <em>inc</em>remented, and where a sequence is destructured with <code>rest</code>, a number is decremented with <code>dec</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">inc</span>    (<span class="kw">inc</span>    (<span class="kw">inc</span>    <span class="dv">0</span>)))   <span class="co">;=&gt; 3</span>
(<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> nil))) <span class="co">;=&gt; (1 2 3)</span>

(<span class="kw">dec</span>  (<span class="kw">dec</span>  (<span class="kw">dec</span>  <span class="dv">3</span>)))       <span class="co">;=&gt; 0</span>
(<span class="kw">rest</span> (<span class="kw">rest</span> (<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))) <span class="co">;=&gt; ()</span></code></pre>
<p>Sequences store more information than numbers – the elements – but otherwise the expressions above are very similar. (The numbers actually encode the length of the sequence. Conversely, sequences can be used to encode numbers. Benjamin Pierce’s <a href="http://www.cis.upenn.edu/~bcpierce/sf/Basics.html#nat">Software Foundations</a> is recommended reading if you’re interested in more off-topic esoterica.) With this relationship, we can make the evaluation of <code>(factorial 4)</code> even more similar to our example of <code>sum</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (factorial (<span class="kw">inc</span> (<span class="kw">inc</span> (<span class="kw">inc</span> (<span class="kw">inc</span> <span class="dv">0</span>))))) <span class="co">; Unwrap inc with dec</span>
<span class="co">;=&gt; (* 4 (factorial (inc (inc (inc 0))))) ; like cons with rest</span>
<span class="co">;=&gt; (* 4 (* 3 (factorial (inc (inc 0))))) ; almost a haiku</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (factorial (inc 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 (factorial 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 1))))             ; Base case reached</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 1)))</span>
<span class="co">;=&gt; (* 4 (* 3 2))</span>
<span class="co">;=&gt; (* 4 6)</span>
<span class="co">;=&gt; 24</span></code></pre>
<p>Let’s define the general template for recursion over (natural) numbers, like we did for sequences.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> eats-numbers </span>[n]
  (<span class="kw">if</span> (<span class="kw">zero?</span> n)
    ...
    (... n ... (eats-numbers (<span class="kw">dec</span> n)))))</code></pre>
<section class="alert alert-success">
<h3>
Exercise 14
</h3>
<p>Write the function <code>(power n k)</code> that computes the mathematical expression \(n^k\).</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(power <span class="dv">2</span> <span class="dv">2</span>)  <span class="co">;=&gt; 4</span>
(power <span class="dv">5</span> <span class="dv">3</span>)  <span class="co">;=&gt; 125</span>
(power <span class="dv">7</span> <span class="dv">0</span>)  <span class="co">;=&gt; 1</span>
(power <span class="dv">0</span> <span class="dv">10</span>) <span class="co">;=&gt; 0</span></code></pre>
</section>
</section>
<section class="level3" id="nonlinear-recursion">
<h3>Nonlinear recursion</h3>
<p>There are other recursive computations besides linear recursion. Another common type is <em>tree recursion</em>. Here <em>tree</em> refers again to the shape of the computation. The natural use for tree recursion is with hierarchical data structures, which we will come back to later. Tree recursion can be illustrated with simple processes over numbers. For an example, let’s look at how to compute the following integer series:</p>
<p>Let \(f(n) = \begin{cases} n &amp; \text{ if } n &lt; 3 \\ f(n - 1) + 2 * f(n - 2) + 3 * f(n - 3) &amp; \text{ otherwise} \end{cases}\)</p>
<p>Translating this to Clojure gives us the following program:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> f </span>[n]
  (<span class="kw">if</span> (<span class="kw">&lt;</span> n <span class="dv">3</span>)
    n
    (<span class="kw">+</span>      (f (<span class="kw">-</span> n <span class="dv">1</span>))
       (<span class="kw">*</span> <span class="dv">2</span> (f (<span class="kw">-</span> n <span class="dv">2</span>)))
       (<span class="kw">*</span> <span class="dv">3</span> (f (<span class="kw">-</span> n <span class="dv">3</span>))))))</code></pre>
<p>(The odd alignment is for clarity.) Consider how this function evaluates:</p>
<figure>
<img src="img/tree-recursion.png" alt="Tree recursion"><figcaption>Tree recursion</figcaption>
</figure>
<p>It is easy to see that the computation forms a tree structure.</p>
<section class="alert alert-success">
<h3>
Exercise 15
</h3>
<p>Compute the \(n\)th <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a>. The \(n\)th Fibonacci number, \(F_n\), is defined as:</p>
<ul>
<li>\(F_0 = 0\)</li>
<li>\(F_1 = 1\)</li>
<li>\(F_n = F_{n-1} + F_{n-2}\)</li>
</ul>
<p>Write the function <code>(fib n)</code> which returns \(F_n\).</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(fib <span class="dv">0</span>) <span class="co">;=&gt; 0</span>
(fib <span class="dv">1</span>) <span class="co">;=&gt; 1</span>
(fib <span class="dv">2</span>) <span class="co">;=&gt; 1</span>
(fib <span class="dv">3</span>) <span class="co">;=&gt; 2</span>
(fib <span class="dv">4</span>) <span class="co">;=&gt; 3</span>
(fib <span class="dv">5</span>) <span class="co">;=&gt; 5</span>
(fib <span class="dv">6</span>) <span class="co">;=&gt; 8</span>
...
(fib <span class="dv">10</span>) <span class="co">;=&gt; 55</span></code></pre>
</section>
</section>
<section class="level3" id="sequence-operations">
<h3>Sequence operations</h3>
<p>We have already implemented some of the sequence functions found from the Clojure’s standard library, namely <code>map</code> and <code>filter</code>. In the following exercises you should use recursion to implement some more.</p>
<section class="alert alert-success">
<h3>
Exercise 16
</h3>

<p>Write the function <code>(my-repeat how-many-times what-to-repeat)</code> that generates a list with <code>what-to-repeat</code> repeated <code>how-many-times</code> number of times.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-repeat <span class="dv">2</span> <span class="kw">:a</span>)    <span class="co">;=&gt; (:a :a)</span>
(my-repeat <span class="dv">3</span> <span class="st">&quot;lol&quot;</span>) <span class="co">;=&gt; (&quot;lol&quot; &quot;lol&quot; &quot;lol&quot;)</span>
(my-repeat -<span class="dv">1</span> <span class="kw">:a</span>)   <span class="co">;=&gt; ()</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 17
</h3>
<p>Write the function <code>(my-range up-to)</code> that works like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-range <span class="dv">0</span>)  <span class="co">;=&gt; ()</span>
(my-range <span class="dv">1</span>)  <span class="co">;=&gt; (0)</span>
(my-range <span class="dv">2</span>)  <span class="co">;=&gt; (1 0)</span>
(my-range <span class="dv">3</span>)  <span class="co">;=&gt; (2 1 0)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 18
</h3>
<p>Write the functions <code>tails</code> and <code>inits</code> that return all the suffixes and prefixes of a sequence, respectively.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(tails [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; ((1 2 3 4) (2 3 4) (3 4) (4) ())</span>
(inits [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (() (1) (1 2) (1 2 3) (1 2 3 4))</span>
<span class="co">; You can output the tails and inits in any order you like.</span>
(inits [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; ((1 2) () (1 2 3) (1) (1 2 3 4))</span></code></pre>
<p><em>Hint:</em> You can use <code>reverse</code> and <code>map</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">reverse</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; (3 2 1)</span>
(<span class="kw">reverse</span> [<span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span>]) <span class="co">;=&gt; (1 3 2)</span></code></pre>
</section>
</section>
<section class="level3" id="passing-state">
<h3>Passing state</h3>
<p>Sometimes when recursing over a structure we want to keep track of something. For an example, we might want to count how many elements we have processed, or how many <code>:D</code> keywords we have seen. How do we do this, in the absence of state in our language? (Or at least in the absence of instructions on how to use state on these pages!)</p>
<p>The answer is two-fold: we store the state explicitly in a parameter we pass back to ourselves on each recursion, and we hide the state from the users of our function by using a helper function that we give an initial empty state to as a parameter.</p>
<p>Here’s an example of a function that counts how many times a sequence contains a given element:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> count-elem-helper </span>[n elem coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    n
    (<span class="kw">let</span> [new-count (<span class="kw">if</span> (<span class="kw">=</span> elem (<span class="kw">first</span> coll))
                      (<span class="kw">inc</span> n)
                      n)]
      (count-elem-helper new-count
                         elem
                         (<span class="kw">rest</span> coll)))))

(<span class="kw">defn</span><span class="fu"> count-elem </span>[elem coll]
    (count-elem-helper <span class="dv">0</span> elem coll))</code></pre>
<p>First, we define a helper function, <code>count-elem-helper</code>. It takes three parameters:</p>
<ul>
<li><p><code>n</code>, which keeps count of how many times we have seen <code>elem</code></p></li>
<li><p><code>elem</code>, which is the element we are looking for</p></li>
<li><p>and <code>coll</code>, which is the collection the function recurses over.</p></li>
</ul>
<p>With this helper function, our definition of <code>count-elem</code> is a simple call to <code>count-elem-helper</code> with <code>n</code> initialized to 0. This way users of <code>count-elem</code> do not need to provide the initialization argument for <code>n</code>.</p>
<section class="alert alert-success">
<h3>
Exercise 19
</h3>
<p>Write the function <code>(rotations a-seq)</code> that, when given a sequence, returns all the rotations of that sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(rotations [])        <span class="co">;=&gt; (())</span>
(rotations [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; ((1 2 3) (2 3 1) (3 1 2))</span>
(rotations [<span class="kw">:a</span> <span class="kw">:b</span>])   <span class="co">;=&gt; ((:a :b) (:b :a))</span>
<span class="co">; The order of rotations does not matter.</span>
(rotations [<span class="kw">:a</span> <span class="kw">:b</span>])   <span class="co">;=&gt; ((:b :a) (:a :b))</span>
(rotations [<span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span>]) <span class="co">;=&gt; ((1 5 9 2) (2 1 5 9) (9 2 1 5) (5 9 2 1))</span>
(<span class="kw">count</span> (rotations [<span class="dv">6</span> <span class="dv">5</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">2</span>])) <span class="co">;=&gt; 5</span></code></pre>
<p>Keep in mind the function <code>concat</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">concat</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>]) <span class="co">;=&gt; (1 2 3 :a :b :c)</span>
(<span class="kw">concat</span> [<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>])    <span class="co">;=&gt; (1 2 3 4 5 6)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 20
</h3>
<p>Write the function <code>(my-frequencies a-seq)</code> that computes a map of how many times each element occurs in a sequence. E.g.:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-frequencies []) <span class="co">;=&gt; {}</span>
(my-frequencies [<span class="kw">:a</span> <span class="st">&quot;moi&quot;</span> <span class="kw">:a</span> <span class="st">&quot;moi&quot;</span> <span class="st">&quot;moi&quot;</span> <span class="kw">:a</span> <span class="dv">1</span>]) <span class="co">;=&gt; {:a 3, &quot;moi&quot; 3, 1 1}</span></code></pre>
<p>You’ll want to structure your code like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> my-frequencies-helper </span>[freqs a-seq]
  ...)

(<span class="kw">defn</span><span class="fu"> my-frequencies </span>[a-seq]
  (frequencies-helper {} a-seq))</code></pre>
<p>Where <code>my-frequencies-helper</code> is a recursive helper function.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 21
</h3>
<p>Write the function <code>(un-frequencies a-map)</code> which takes a map produced by <code>my-frequencies</code> and generates a sequence with the corresponding numbers of different elements.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(un-frequencies {<span class="kw">:a</span> <span class="dv">3</span> <span class="kw">:b</span> <span class="dv">2</span> <span class="st">&quot;^_^&quot;</span> <span class="dv">1</span>})             <span class="co">;=&gt; (:a :a :a &quot;^_^&quot; :b :b)</span>
(un-frequencies (my-frequencies [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span> <span class="kw">:a</span>]))  <span class="co">;=&gt; (:a :a :b :c)</span>
(my-frequencies (un-frequencies {<span class="kw">:a</span> <span class="dv">100</span> <span class="kw">:b</span> <span class="dv">10</span>})) <span class="co">;=&gt; {:a 100 :b 10}</span></code></pre>
<p>The order of elements in the output sequence doesn’t matter.</p>
<p>Hint 1: Remember that you can use <code>first</code> and <code>rest</code> on a map too!</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">first</span> {<span class="kw">:a</span> <span class="dv">1</span> <span class="kw">:b</span> <span class="dv">2</span>}) <span class="co">;=&gt; [:a 1]</span>
(<span class="kw">rest</span> {<span class="kw">:a</span> <span class="dv">1</span> <span class="kw">:b</span> <span class="dv">2</span> <span class="kw">:c</span> <span class="dv">3</span>}) <span class="co">;=&gt; ([:b 2] [:c 3])</span></code></pre>
<p>Hint 2: There are multiple ways to implement this, but consider using <code>concat</code> and <code>repeat</code>.</p>
</section>
</section>
<section class="level3" id="merging-and-sorting">
<h3>Merging and sorting</h3>
<p>As a grand finale, lets implement the classic merge sort. We have split the task into smaller exercises.</p>
<section class="alert alert-success">
<h3>
Exercise 22
</h3>
<p>Implement <code>(my-take n coll)</code> that returns <code>n</code> first items of coll.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-take <span class="dv">2</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (1 2)</span>
(my-take <span class="dv">4</span> [<span class="kw">:a</span> <span class="kw">:b</span>])   <span class="co">;=&gt; (:a :b)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 23
</h3>
<p>Implement <code>(my-drop n coll)</code> that returns all but the <code>n</code> first items of coll.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-drop <span class="dv">2</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (3 4)</span>
(my-drop <span class="dv">4</span> [<span class="kw">:a</span> <span class="kw">:b</span>])   <span class="co">;=&gt; ()</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 24
</h3> 
<p>Implement the function <code>(halve a-seq)</code> that takes a sequence and returns one vector with two elements. The first element is the first half of <code>a-seq</code> and the second element is the second half of <code>a-seq</code>.</p>
<p>To turn a result of division into an integer use <code>int</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">int</span> (<span class="kw">/</span> <span class="dv">7</span> <span class="dv">2</span>)) <span class="co">;=&gt; 3</span></code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(halve [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; [(1 2) (3 4)]</span>
(halve [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>]) <span class="co">;=&gt; [(1 2) (3 4 5)]</span>
(halve [<span class="dv">1</span>])         <span class="co">;=&gt; [() (1)]</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 25
</h3>
<p>Write the function <code>(seq-merge a-seq b-seq)</code> that takes two (low to high) sorted number sequences and combines them into one sorted sequence. E.g.:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(seq-merge [<span class="dv">4</span>] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">6</span> <span class="dv">7</span>])        <span class="co">;=&gt; (1 2 4 6 7)</span>
(seq-merge [<span class="dv">1</span> <span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>] [<span class="dv">2</span> <span class="dv">2</span> <span class="dv">8</span> <span class="dv">10</span>]) <span class="co">;=&gt; (1 2 2 5 7 8 9 10)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 26
</h3>

<p>Write the function <code>(merge-sort a-seq)</code> that implements <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a>.</p>
<p>The idea of merge sort is to divide the input into subsequences using <code>halve</code>, sort the subsequences recursively and use the <code>seq-merge</code> function to merge the sorted subsequences back together.</p>
<p>Conceptually:</p>
<ul>
<li>If the sequence is 0 or 1 elements long, it is already sorted.</li>
<li>Otherwise, divide the sequence into two subsequences.</li>
<li>Sort each subsequence recursively.</li>
<li>Merge the two subsequences back into one sorted sequence.</li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (merge-sort [<span class="dv">4</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span>])
<span class="co">;=&gt; (seq-merge (merge-sort (4 2))</span>
<span class="co">;              (merge-sort (3 1)))</span>
<span class="co">;=&gt; (seq-merge (seq-merge (merge-sort (4))</span>
<span class="co">;                         (merge-sort (2)))</span>
<span class="co">;              (seq-merge (merge-sort (3))</span>
<span class="co">;                         (merge-sort (1))))</span>
<span class="co">;=&gt; (seq-merge (seq-merge (4) (2))</span>
<span class="co">;              (seq-merge (3) (1)))</span>
<span class="co">;=&gt; (seq-merge (2 4) (1 3))</span>
<span class="co">;=&gt; (1 2 3 4)</span></code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(merge-sort [])                 <span class="co">;=&gt; ()</span>
(merge-sort [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])            <span class="co">;=&gt; (1 2 3)</span>
(merge-sort [<span class="dv">5</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">17</span> <span class="dv">2</span> <span class="dv">100</span> <span class="dv">1</span>]) <span class="co">;=&gt; (1 2 3 4 5 17 100)</span></code></pre>
</section>
</section>
</section>
<section class="level2" id="encore">
<h2>Encore</h2>
<p>The following exercises are ment to be tricky. For that reason they give more points than the regular ones. But don’t worry if</p>
<section class="alert alert-success">
<h3>
Exercise 27
</h3>

<p>Write the function <code>split-into-monotonics</code> that takes a sequence and returns the sequence split into monotonic pieces. Examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(split-into-monotonics [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>])   <span class="co">;=&gt; ((0 1 2) (1 0))</span>
(split-into-monotonics [<span class="dv">0</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">3</span>]) <span class="co">;=&gt; ((0 5) (4 7) (1 3))</span></code></pre>
<p><em>Hint:</em> You might find useful the functions <code>take-while</code>, <code>drop</code> and <code>inits</code>. Make sure that your <code>inits</code> returns the prefixes from the shortest to the longest.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(inits [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (() (1) (1 2) (1 2 3) (1 2 3 4))</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 28
</h3>
<p>Given a sequence, return all permutations of that sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(permutations #{})
<span class="co">;=&gt; (())</span>
(permutations #{<span class="dv">1</span> <span class="dv">5</span> <span class="dv">3</span>})
<span class="co">;=&gt; ((1 5 3) (5 1 3) (5 3 1) (1 3 5) (3 1 5) (3 5 1))</span></code></pre>
<p>The order of the permutations doesn’t matter.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 29
</h3>
<p>Given a set, return the powerset of that set.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(powerset #{})      <span class="co">;=&gt; #{#{}}</span>
(powerset #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>}) <span class="co">;=&gt; #{#{} #{4} #{2} #{2 4} #{1} #{1 4} #{1 2} #{1 2 4}}</span></code></pre>
</section>
</section>
<footer>
    <p>
        &copy; <a href="http://iloveponies.github.com">iloveponies</a>.

        <span style="float: right">
            <a href="mailto:ilmari.vacklin@gmail.com">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</div>
</body>
</html>
